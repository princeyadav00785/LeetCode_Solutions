{"id":992367585,"lang":"cpp","lang_name":"C++","time":"4 months, 1 week","timestamp":1689137533,"status":10,"status_display":"Accepted","runtime":"236 ms","url":"/submissions/detail/992367585/","is_pending":"Not Pending","title":"Find Eventual Safe States","memory":"62.2 MB","code":"class Solution {\npublic:\n   vector<int> eventualSafeNodes(vector<vector<int>>& G) {\n    int N = G.size();\n    vector<vector<int>> R(N);\n    vector<int> outdegree(N), safe(N), ans;\n    queue<int> q;\n    for (int i = 0; i < N; ++i) {\n        for (int v : G[i]) {\n            R[v].push_back(i);\n        }\n        outdegree[i] = G[i].size();\n        if (outdegree[i] == 0) q.push(i);\n    }\n    while (q.size()) {\n        int u = q.front();\n        q.pop();\n        safe[u] = 1;\n        for (int v : R[u]) {\n            if (--outdegree[v] == 0) q.push(v);\n        }\n    }\n    for (int i = 0; i < N; ++i) {\n        if (safe[i]) ans.push_back(i);\n    }\n    return ans;\n}};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"find-eventual-safe-states","has_notes":false,"flag_type":1}