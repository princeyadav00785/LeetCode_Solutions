{"id":999851185,"lang":"cpp","lang_name":"C++","time":"3 months, 4 weeks","timestamp":1689911476,"status":10,"status_display":"Accepted","runtime":"327 ms","url":"/submissions/detail/999851185/","is_pending":"Not Pending","title":"Longest Increasing Subsequence II","memory":"138.4 MB","code":"class MaxSegmentTree {\n public:\n  int n;\n  vector<int> tree;\n  MaxSegmentTree(int n_) : n(n_) {\n    int size = (int)(ceil(log2(n)));\n    size = (2 * pow(2, size)) - 1;\n    tree = vector<int>(size);\n  }\n  \n  int max_value() { return tree[0]; }\n\n  int query(int l, int r) { return query_util(0, l, r, 0, n - 1); }\n\n  int query_util(int i, int qL, int qR, int l, int r) {\n    if (l >= qL && r <= qR) return tree[i];\n    if (l > qR || r < qL) return INT_MIN;\n\n    int m = (l + r) / 2;\n    return max(query_util(2 * i + 1, qL, qR, l, m), query_util(2 * i + 2, qL, qR, m + 1, r));\n  }\n\n  void update(int i, int val) { update_util(0, 0, n - 1, i, val); }\n  void update_util(int i, int l, int r, int pos, int val) {\n    if (pos < l || pos > r) return;\n    if (l == r) {\n      tree[i] = max(val, tree[i]);\n      return;\n    }\n\n    int m = (l + r) / 2;\n    update_util(2 * i + 1, l, m, pos, val);\n    update_util(2 * i + 2, m + 1, r, pos, val);\n    tree[i] = max(tree[2 * i + 1], tree[2 * i + 2]);\n  }\n};\n\nclass Solution {\n public:\n  int lengthOfLIS(vector<int>& nums, int k) {\n    MaxSegmentTree tree(1e5 + 1);\n    for (int i : nums) {\n      int lower = max(0, i - k);\n      int cur = 1 + tree.query(lower, i - 1);\n      tree.update(i, cur);\n    }\n\n    return tree.max_value();\n  }\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"longest-increasing-subsequence-ii","has_notes":false,"flag_type":1}