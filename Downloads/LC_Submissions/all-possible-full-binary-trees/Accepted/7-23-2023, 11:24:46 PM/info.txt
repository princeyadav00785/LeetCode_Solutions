{"id":1002009343,"lang":"cpp","lang_name":"C++","time":"3 months, 3 weeks","timestamp":1690134886,"status":10,"status_display":"Accepted","runtime":"105 ms","url":"/submissions/detail/1002009343/","is_pending":"Not Pending","title":"All Possible Full Binary Trees","memory":"28.2 MB","code":"class Solution {\npublic:\n    vector<vector<TreeNode*>>dp;\n    \n    vector<TreeNode*> solve(int n)\n    {\n       \n        \n        if(n % 2 == 0)\n            return {};\n        \n        if(dp[n].size()!=0)\n        return dp[n];\n        \n        if(n == 1)    \n        {\n            TreeNode* new_node = new TreeNode(0);\n            \n            return {new_node};\n        }\n        \n        vector<TreeNode*> res;\n        \n        for(int i = 1; i < n; i+=2)\n        {\n            \n            vector<TreeNode*>left = solve(i);\n            \n            \n            vector<TreeNode*>right = solve(n - i - 1);\n            \n            for( TreeNode*l: left)\n            {\n                for(TreeNode*r : right)\n                {\n                    \n                    TreeNode* root = new TreeNode(0);\n                    \n                    root -> left = l;\n                    \n                    root -> right = r;\n                    \n                    \n                    res.push_back(root);\n                }\n            }\n        }\n        \n        \n        \n        return dp[n]=res;\n    }\n    \n    vector<TreeNode*> allPossibleFBT(int n) {\n        dp.resize(n+1);\n        return solve(n);\n    }\n};","compare_result":"11111111111111111111","title_slug":"all-possible-full-binary-trees","has_notes":false,"flag_type":1}