{"id":1077245149,"lang":"cpp","lang_name":"C++","time":"1Â month","timestamp":1697519170,"status":10,"status_display":"Accepted","runtime":"34 ms","url":"/submissions/detail/1077245149/","is_pending":"Not Pending","title":"Validate Binary Tree Nodes","memory":"32.5 MB","code":"class Solution {\npublic:\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\n        vector<int>inDegree(n,0);\n        // Calculate in-degrees for each node\n        for (int i = 0; i < n; i++) {\n            if (leftChild[i] != -1) {\n                inDegree[leftChild[i]]++;\n                if (inDegree[leftChild[i]] > 1) {\n                    return false; // More than one incoming edge to a node\n                }\n            }\n            if (rightChild[i] != -1) {\n                inDegree[rightChild[i]]++;\n                if (inDegree[rightChild[i]] > 1) {\n                    return false; // More than one incoming edge to a node\n                }\n            }\n        }\n      \n        \n        int rootNode = -1;\n        // Find the root node (a node with in-degree 0)\n        for (int i = 0; i < n; i++) {\n            if (inDegree[i] == 0) {\n                if (rootNode != -1) {\n                    return false; // More than one root node\n                }\n                rootNode = i;\n            }\n        }\n        \n        if (rootNode == -1) {\n            return false; // No root node found\n        }\n        \n        // Perform a depth-first traversal to check if the tree is connected\n        vector<bool> visited(n, false);\n        stack<int> dfs;\n        dfs.push(rootNode);\n        \n        while (!dfs.empty()) {\n            int node = dfs.top();\n            dfs.pop();\n            \n            if (visited[node]) {\n                return false; // Cycle detected\n            }\n            \n            visited[node] = true;\n            \n            if (leftChild[node] != -1) {\n                dfs.push(leftChild[node]);\n            }\n            if (rightChild[node] != -1) {\n                dfs.push(rightChild[node]);\n            }\n        }\n        \n        // Check if all nodes are visited\n        for (int i = 0; i < n; i++) {\n            if (!visited[i]) {\n                return false; // Some nodes are not reachable\n            }\n        }\n        \n        return true;\n\n    }\n};\n","compare_result":"11111111111111111111111111111111111111111111","title_slug":"validate-binary-tree-nodes","has_notes":false,"flag_type":1}