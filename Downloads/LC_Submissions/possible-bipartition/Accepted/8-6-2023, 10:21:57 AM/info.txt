{"id":1013529209,"lang":"cpp","lang_name":"C++","time":"3 months, 1 week","timestamp":1691297517,"status":10,"status_display":"Accepted","runtime":"179 ms","url":"/submissions/detail/1013529209/","is_pending":"Not Pending","title":"Possible Bipartition","memory":"71.2 MB","code":"class Solution {\npublic:\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\n        \n        vector<int> color(n+1,-1);\n        vector<int> adj[n+1];\n        for(auto p:dislikes){\n            adj[p[0]].push_back(p[1]);\n            adj[p[1]].push_back(p[0]);\n        }\n        for(int node=1;node<=n;node++){\n            if(color[node]==-1){\n                \n                if(cycle(node,adj,color)){\n                    return false; // if adjacent node become same color as \n                                  // current node, no bipartition possible\n                }\n            }\n        }\n        return true;\n    }\n    bool cycle(int node,vector<int> adj[], vector<int> &color){\n        if(color[node]==-1){\n            color[node]=1;\n        }\n        for(int child:adj[node]){\n            if(color[child]==-1){\n                color[child]=1-color[node];\n                if(cycle(child,adj,color)){\n                    return true; // finding adjacent node having same color\n                }\n            }\n            else if(color[child]==color[node]){\n                return true;// finding adjacent node having same color\n            }\n        }\n        return false;\n    }\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"possible-bipartition","has_notes":false,"flag_type":1}