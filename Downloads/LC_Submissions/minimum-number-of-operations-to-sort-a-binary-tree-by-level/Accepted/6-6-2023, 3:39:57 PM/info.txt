{"id":965064434,"lang":"cpp","lang_name":"C++","time":"5 months, 1 week","timestamp":1686046197,"status":10,"status_display":"Accepted","runtime":"973 ms","url":"/submissions/detail/965064434/","is_pending":"Not Pending","title":"Minimum Number of Operations to Sort a Binary Tree by Level","memory":"165.5 MB","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n//     int fxn(TreeNode*root){\n//         int cnt=0;\n//         // vector<vector<int>>ans;\n//         queue<TreeNode*> q;\n//         if(root==NULL){return cnt;}\n//         q.push(root);\n//         while(q.size()){\n//             vector<int> v;\n//             int m=0;\n//             int n= q.size();\n//             for(int i=0;i<n;i++){\n//                  TreeNode* a= q.front();\n//                 q.pop();\n//                 if(a!=NULL){ \n//                 if(a->left) q.push(a->left);\n//                    if(a->right) q.push(a->right);\n//                 v.push_back(a->val);} \n                \n//             }\n//             vector<int>x(v.begin(),v.end());\n//             sort(x.begin(),x.end());\n//             for(int i=0;i<v.size();i++){\n//                 if(v[i]!=x[i]){cnt++;m=1;}\n//             }\n//             if(m==1){cnt=cnt-1;}\n//               // ans.push_back(v);   \n//         }\n//         return cnt;\n//     }\n    \n//     int minimumOperations(TreeNode* root) {\n//       int ans= fxn(root);\n//         return ans;\n    \n       int countSwap(vector<int>& t){\n        int count = 0;\n        map<int,int> mp;\n        vector<int> u;\n        for(int i = 0; i < t.size(); ++i){\n            mp[t[i]] = i;\n            u.push_back(t[i]);\n        }\n        sort(u.begin(), u.end());\n        for(int i = 0; i < t.size(); ++i){\n            if(t[i] != u[i] ){  // if not at correct place update the values in map and t array\n                t[mp[u[i]]] = t[i];\n                mp[t[i]] = mp[u[i]];\n                mp[u[i]] = i;\n                t[i] = u[i];\n                count++;\n            }\n        }\n        return count;\n    }\n    int minimumOperations(TreeNode* root) {\n        int ans = 0;\n        queue<TreeNode*> q;\n        q.push(root);\n        while(!q.empty()){\n            int n = q.size();\n            vector<int> t;\n            while(n--){\n                TreeNode* node = q.front();\n                t.push_back(node->val);\n                q.pop();\n                if(node->left != NULL) q.push(node->left);\n                if(node->right != NULL) q.push(node->right);\n            }\n            for(auto c: t) cout<<c<<\" \"; cout<<endl;\n            ans += countSwap(t);\n        }\n        return ans;\n    }\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"minimum-number-of-operations-to-sort-a-binary-tree-by-level","has_notes":false,"flag_type":1}