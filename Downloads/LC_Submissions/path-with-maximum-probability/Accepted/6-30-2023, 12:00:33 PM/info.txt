{"id":982857188,"lang":"cpp","lang_name":"C++","time":"4 months, 2 weeks","timestamp":1688106633,"status":10,"status_display":"Accepted","runtime":"194 ms","url":"/submissions/detail/982857188/","is_pending":"Not Pending","title":"Path with Maximum Probability","memory":"65.6 MB","code":"class Solution {\npublic:\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\n\n        // Adjacency list\n        vector<vector<pair<int, double>>> adj(n);\n        for (int i = 0; i < edges.size(); i++) {\n            int u = edges[i][0];\n            int v = edges[i][1];\n            adj[u].push_back({v, succProb[i]});\n            adj[v].push_back({u, succProb[i]});\n        }\n\n        // ans will be in dist[end]\n        vector<double> dist(n, 0.0);\n        dist[start] = 1.0;\n        \n        queue<int> q;\n        q.push(start);\n        \n        while (!q.empty()) {\n            int curr = q.front();\n            q.pop();\n            \n            for (auto x : adj[curr]) {\n                int node = x.first;\n                double prob = x.second;\n                double newProb = dist[curr] * prob;\n                \n                if (newProb > dist[node]) {\n                    dist[node] = newProb;\n                    q.push(node);\n                }\n            }\n        }\n        \n        return dist[end];\n    }\n};","compare_result":"111111111111111111","title_slug":"path-with-maximum-probability","has_notes":false,"flag_type":1}